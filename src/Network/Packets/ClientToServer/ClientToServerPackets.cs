// <copyright file="ClientToServerPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ClientToServer
{
    using System;

    /// <summary>
    /// Is sent by the client when: This packet is sent by the client every few seconds. It contains the current "TickCount" of the client operating system and the attack speed of the selected character.
    /// Causes reaction on server side: By the original server this is used to detect speed hacks.
    /// </summary>
    public ref struct Ping
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Ping"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Ping(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Ping"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private Ping(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x0E;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the tick count.
        /// </summary>
        public uint TickCount
        {
            get => this.data.Slice(4).GetIntegerBigEndian();
            set => this.data.Slice(4).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the speed 1.
        /// </summary>
        public byte Speed1
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the speed 2.
        /// </summary>
        public byte Speed2
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Gets or sets the speed 3.
        /// </summary>
        public byte Speed3
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the speed 4.
        /// </summary>
        public byte Speed4
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="Ping"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator Ping(Span<byte> packet) => new Ping(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Ping"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(Ping packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player sends a public chat message.
    /// Causes reaction on server side: The message is forwarded to all surrounding players, including the sender.
    /// </summary>
    public ref struct PublicChatMessage
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PublicChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PublicChatMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PublicChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PublicChatMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the character.
        /// </summary>
        public string Character
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(13, this.data.Length - 13, System.Text.Encoding.UTF8);
            set => this.data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PublicChatMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PublicChatMessage(Span<byte> packet) => new PublicChatMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PublicChatMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PublicChatMessage packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player sends a private chat message to a specific target player.
    /// Causes reaction on server side: The message is forwarded to the target player.
    /// </summary>
    public ref struct WhisperMessage
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="WhisperMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public WhisperMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WhisperMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private WhisperMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x02;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the receiver name.
        /// </summary>
        public string ReceiverName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(13, this.data.Length - 13, System.Text.Encoding.UTF8);
            set => this.data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="WhisperMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator WhisperMessage(Span<byte> packet) => new WhisperMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="WhisperMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(WhisperMessage packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player tries to log into the game.
    /// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
    /// </summary>
    public ref struct LoginLongPassword
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginLongPassword"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LoginLongPassword(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginLongPassword"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LoginLongPassword(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the user name, "encrypted" with Xor3.
        /// </summary>
        public Span<byte> Username
        {
            get => this.data.Slice(4, 10);
        }

        /// <summary>
        /// Gets or sets the password, "encrypted" with Xor3.
        /// </summary>
        public Span<byte> Password
        {
            get => this.data.Slice(14, 20);
        }

        /// <summary>
        /// Gets or sets the tick count.
        /// </summary>
        public uint TickCount
        {
            get => this.data.Slice(34).GetIntegerLittleEndian();
            set => this.data.Slice(34).SetIntegerLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the client version.
        /// </summary>
        public Span<byte> ClientVersion
        {
            get => this.data.Slice(38, 5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginLongPassword"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LoginLongPassword(Span<byte> packet) => new LoginLongPassword(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LoginLongPassword"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LoginLongPassword packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player tries to log into the game.
    /// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
    /// </summary>
    public ref struct LoginShortPassword
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginShortPassword"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LoginShortPassword(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginShortPassword"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LoginShortPassword(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the user name, "encrypted" with Xor3.
        /// </summary>
        public Span<byte> Username
        {
            get => this.data.Slice(4, 10);
        }

        /// <summary>
        /// Gets or sets the password, "encrypted" with Xor3.
        /// </summary>
        public Span<byte> Password
        {
            get => this.data.Slice(14, 10);
        }

        /// <summary>
        /// Gets or sets the tick count.
        /// </summary>
        public uint TickCount
        {
            get => this.data.Slice(24).GetIntegerLittleEndian();
            set => this.data.Slice(24).SetIntegerLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the client version.
        /// </summary>
        public Span<byte> ClientVersion
        {
            get => this.data.Slice(28, 5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginShortPassword"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LoginShortPassword(Span<byte> packet) => new LoginShortPassword(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LoginShortPassword"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LoginShortPassword packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player tries to log into the game.
    /// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
    /// </summary>
    public ref struct Login075
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Login075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Login075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Login075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private Login075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the user name, "encrypted" with Xor3.
        /// </summary>
        public Span<byte> Username
        {
            get => this.data.Slice(4, 10);
        }

        /// <summary>
        /// Gets or sets the password, "encrypted" with Xor3.
        /// </summary>
        public Span<byte> Password
        {
            get => this.data.Slice(14, 10);
        }

        /// <summary>
        /// Gets or sets the tick count.
        /// </summary>
        public uint TickCount
        {
            get => this.data.Slice(24).GetIntegerLittleEndian();
            set => this.data.Slice(24).SetIntegerLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the client version.
        /// </summary>
        public Span<byte> ClientVersion
        {
            get => this.data.Slice(28, 3);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="Login075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator Login075(Span<byte> packet) => new Login075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Login075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(Login075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: When the client wants to leave the game in various ways.
    /// Causes reaction on server side: Depending on the LogOutType, the game server does several checks and sends a response back to the client. If the request was successful, the game client either closes the game, goes back to server or character selection.
    /// </summary>
    public ref struct LogOut
    {
        /// <summary>
        /// Describes the way how the player wants to leave the current game.
        /// </summary>
        public enum LogOutType
        {
            /// <summary>
            /// The player wants to close the game.
            /// </summary>
            CloseGame = 0,

            /// <summary>
            /// The player wants to go back to the character selection screen.
            /// </summary>
            BackToCharacterSelection = 1,

            /// <summary>
            /// The player wants to go back to the server selection screen.
            /// </summary>
            BackToServerSelection = 2,
        }

        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LogOut"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LogOut(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogOut"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LogOut(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public LogOutType Type
        {
            get => (LogOutType)this.data.Slice(4).GetByteValue();
            set => this.data.Slice(4).SetByteValue((byte)value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LogOut"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LogOut(Span<byte> packet) => new LogOut(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LogOut"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LogOut packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player wants to set a price of an item which is inside his personal item shop.
    /// Causes reaction on server side: The price is set for the specified item. Works only if the shop is currently closed.
    /// </summary>
    public ref struct PlayerShopSetItemPrice
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopSetItemPrice"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopSetItemPrice(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopSetItemPrice"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopSetItemPrice(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the price.
        /// </summary>
        public uint Price
        {
            get => this.data.Slice(5).GetIntegerBigEndian();
            set => this.data.Slice(5).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopSetItemPrice"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopSetItemPrice(Span<byte> packet) => new PlayerShopSetItemPrice(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopSetItemPrice"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopSetItemPrice packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player wants to open his personal item shop.
    /// Causes reaction on server side: The personal item shop is opened and the surrounding players are informed about it, including the own player.
    /// </summary>
    public ref struct PlayerShopOpen
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopOpen"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopOpen(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopOpen"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopOpen(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the store name.
        /// </summary>
        public string StoreName
        {
            get => this.data.ExtractString(4, 26, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 26).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopOpen"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopOpen(Span<byte> packet) => new PlayerShopOpen(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopOpen"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopOpen packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player wants to close his personal item shop.
    /// Causes reaction on server side: The personal item shop is closed and the surrounding players are informed about it, including the own player.
    /// </summary>
    public ref struct PlayerShopClose
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopClose"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopClose(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopClose"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopClose(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopClose"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopClose(Span<byte> packet) => new PlayerShopClose(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopClose"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopClose packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player opens a shop of another player.
    /// Causes reaction on server side: The list of items is sent back, if the shop of the player is currently open.
    /// </summary>
    public ref struct PlayerShopItemListRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemListRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItemListRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemListRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopItemListRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the player name.
        /// </summary>
        public string PlayerName
        {
            get => this.data.ExtractString(6, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemListRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopItemListRequest(Span<byte> packet) => new PlayerShopItemListRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopItemListRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopItemListRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to buy the item of another players shop.
    /// Causes reaction on server side: If the buyer has enough money, the item is sold to the player. Both players will get notifications about that.
    /// </summary>
    public ref struct PlayerShopItemBuyRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemBuyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItemBuyRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemBuyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopItemBuyRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the player name.
        /// </summary>
        public string PlayerName
        {
            get => this.data.ExtractString(6, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[16];
            set => this.data[16] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemBuyRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopItemBuyRequest(Span<byte> packet) => new PlayerShopItemBuyRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopItemBuyRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopItemBuyRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to pick up an item which is laying on the ground in the near of the players character.
    /// Causes reaction on server side: If the player is allowed to pick the item up, and is the first player which tried that, it tries to add the item to the inventory. The server sends a response about the result of the request.
    /// </summary>
    public ref struct PickupItemRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PickupItemRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PickupItemRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PickupItemRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PickupItemRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the item id.
        /// </summary>
        public ushort ItemId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PickupItemRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PickupItemRequest(Span<byte> packet) => new PickupItemRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PickupItemRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PickupItemRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to pick up an item which is laying on the ground in the near of the players character.
    /// Causes reaction on server side: If the player is allowed to pick the item up, and is the first player which tried that, it tries to add the item to the inventory. The server sends a response about the result of the request.
    /// </summary>
    public ref struct PickupItemRequest075
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PickupItemRequest075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PickupItemRequest075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PickupItemRequest075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PickupItemRequest075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the item id.
        /// </summary>
        public ushort ItemId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PickupItemRequest075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PickupItemRequest075(Span<byte> packet) => new PickupItemRequest075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PickupItemRequest075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PickupItemRequest075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to drop on item of his inventory on the ground.
    /// Causes reaction on server side: When the specified coordinates are valid, and the item is allowed to be dropped, it will be dropped on the ground and the surrounding players are notified.
    /// </summary>
    public ref struct DropItemRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="DropItemRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public DropItemRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DropItemRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private DropItemRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x23;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="DropItemRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator DropItemRequest(Span<byte> packet) => new DropItemRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="DropItemRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(DropItemRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to move an item within or between his available item storage, such as inventory, vault, trade or chaos machine.
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct ItemMoveRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoveRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemMoveRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoveRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemMoveRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x24;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the from storage.
        /// </summary>
        public byte FromStorage
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the from slot.
        /// </summary>
        public byte FromSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the to storage.
        /// </summary>
        public byte ToStorage
        {
            get => this.data[17];
            set => this.data[17] = value;
        }

        /// <summary>
        /// Gets or sets the to slot.
        /// </summary>
        public byte ToSlot
        {
            get => this.data[18];
            set => this.data[18] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoveRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemMoveRequest(Span<byte> packet) => new ItemMoveRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemMoveRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemMoveRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct ConsumeItem
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConsumeItem(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConsumeItem(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the target slot.
        /// </summary>
        public byte TargetSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItem"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConsumeItem(Span<byte> packet) => new ConsumeItem(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConsumeItem"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConsumeItem packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct TalkToNpc
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TalkToNpc"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TalkToNpc(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TalkToNpc"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TalkToNpc(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x30;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the npc id.
        /// </summary>
        public ushort NpcId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TalkToNpc"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TalkToNpc(Span<byte> packet) => new TalkToNpc(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TalkToNpc"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TalkToNpc packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct CloseNpc
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CloseNpc"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CloseNpc(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CloseNpc"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CloseNpc(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x31;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CloseNpc"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CloseNpc(Span<byte> packet) => new CloseNpc(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CloseNpc"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CloseNpc packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct BuyItemFromNpcRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="BuyItemFromNpcRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public BuyItemFromNpcRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BuyItemFromNpcRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private BuyItemFromNpcRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x32;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets item Slot (NPC Store)
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="BuyItemFromNpcRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator BuyItemFromNpcRequest(Span<byte> packet) => new BuyItemFromNpcRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="BuyItemFromNpcRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(BuyItemFromNpcRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct SellItemToNpc
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SellItemToNpc"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SellItemToNpc(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SellItemToNpc"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SellItemToNpc(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x33;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets item Slot (Inventory)
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SellItemToNpc"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SellItemToNpc(Span<byte> packet) => new SellItemToNpc(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SellItemToNpc"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SellItemToNpc packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct WarpCommand
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="WarpCommand"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public WarpCommand(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WarpCommand"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private WarpCommand(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x8E;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the warp info id.
        /// </summary>
        public ushort WarpInfoId
        {
            get => this.data.Slice(8).GetShortBigEndian();
            set => this.data.Slice(8).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="WarpCommand"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator WarpCommand(Span<byte> packet) => new WarpCommand(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="WarpCommand"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(WarpCommand packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct EnterGate
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="EnterGate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public EnterGate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EnterGate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private EnterGate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1C;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the gate number.
        /// </summary>
        public ushort GateNumber
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="EnterGate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator EnterGate(Span<byte> packet) => new EnterGate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="EnterGate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(EnterGate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct VaultClose
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultClose"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultClose(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultClose"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultClose(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x82;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultClose"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultClose(Span<byte> packet) => new VaultClose(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultClose"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultClose packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct LahapJewelMix
    {
        /// <summary>
        /// Describes what kind of operation is requested.
        /// </summary>
        public enum MixOrUnmix
        {
            /// <summary>
            /// The player wants to mix single jewels into a bundle.
            /// </summary>
            Mix = 0,

            /// <summary>
            /// The player wants to disband a bundle into single jewels.
            /// </summary>
            Unmix = 1,
        }

        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LahapJewelMix"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LahapJewelMix(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LahapJewelMix"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LahapJewelMix(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xBC;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the mix type.
        /// </summary>
        public MixOrUnmix MixType
        {
            get => (MixOrUnmix)this.data.Slice(3).GetByteValue();
            set => this.data.Slice(3).SetByteValue((byte)value);
        }

        /// <summary>
        /// Gets or sets the jewel type.
        /// </summary>
        public byte JewelType
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the mixing stack size.
        /// </summary>
        public byte MixingStackSize
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the unmixing source slot.
        /// </summary>
        public byte UnmixingSourceSlot
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LahapJewelMix"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LahapJewelMix(Span<byte> packet) => new LahapJewelMix(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LahapJewelMix"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LahapJewelMix packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct RequestPartyList
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestPartyList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RequestPartyList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestPartyList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RequestPartyList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RequestPartyList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RequestPartyList(Span<byte> packet) => new RequestPartyList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RequestPartyList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RequestPartyList packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct PartyPlayerKick
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyPlayerKick"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyPlayerKick(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyPlayerKick"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyPlayerKick(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x43;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the player index.
        /// </summary>
        public byte PlayerIndex
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyPlayerKick"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyPlayerKick(Span<byte> packet) => new PartyPlayerKick(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyPlayerKick"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyPlayerKick packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct PartyRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x40;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the target player id.
        /// </summary>
        public ushort TargetPlayerId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyRequest(Span<byte> packet) => new PartyRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct PartyResponse
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x41;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the accepted.
        /// </summary>
        public bool Accepted
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyResponse(Span<byte> packet) => new PartyResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct Walk
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Walk"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Walk(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Walk"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private Walk(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xD4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the source x.
        /// </summary>
        public byte SourceX
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the source y.
        /// </summary>
        public byte SourceY
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the directions.
        /// </summary>
        public Span<byte> Directions
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="Walk"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator Walk(Span<byte> packet) => new Walk(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Walk"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(Walk packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: It's sent when the player performs specific skills.
    /// Causes reaction on server side: Usually, the player is moved instantly to the specified coordinates on the current map. In OpenMU, this request is not handled, because it allows hackers to "teleport" to any coordinates.
    /// </summary>
    public ref struct InstantMoveRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="InstantMoveRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public InstantMoveRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstantMoveRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private InstantMoveRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="InstantMoveRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator InstantMoveRequest(Span<byte> packet) => new InstantMoveRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="InstantMoveRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(InstantMoveRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct Animation
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Animation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Animation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Animation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private Animation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x18;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the animation number.
        /// </summary>
        public byte AnimationNumber
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="Animation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator Animation(Span<byte> packet) => new Animation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Animation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(Animation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: After a successful login or after the player decided to leave the game world to go back to the character selection screen.
    /// Causes reaction on server side: The server sends the character list with all available characters.
    /// </summary>
    public ref struct RequestCharacterList
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestCharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RequestCharacterList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RequestCharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RequestCharacterList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RequestCharacterList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RequestCharacterList(Span<byte> packet) => new RequestCharacterList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RequestCharacterList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RequestCharacterList packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The game client is at the character selection screen and the player requests to add a new character.
    /// Causes reaction on server side: The server checks if the player is allowed to create the character and sends a response back.
    /// </summary>
    public ref struct CreateCharacter
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CreateCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CreateCharacter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CreateCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CreateCharacter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the name of the character which should be created.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the character class of the character which should be created.
        /// </summary>
        public CharacterClassNumber Class
        {
            get => (CharacterClassNumber)this.data.Slice(14).GetByteValue(6, 2);
            set => this.data.Slice(14).SetByteValue((byte)value, 6, 2);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CreateCharacter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CreateCharacter(Span<byte> packet) => new CreateCharacter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CreateCharacter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CreateCharacter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The game client is at the character selection screen and the player requests to delete an existing character.
    /// Causes reaction on server side: The server checks if the player transmitted the correct security code and if the character actually exists. If all is valid, it deletes the character from the account. It then sends a response with a result code back to the game client.
    /// </summary>
    public ref struct DeleteCharacter
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="DeleteCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public DeleteCharacter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DeleteCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private DeleteCharacter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the name of the character which should be deleted.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets a security code (7 bytes long). Some game clients/servers also expect to transmit the account password (up to 20 bytes long) here. In OpenMU, we work with the security here, but are not limiting to a length of 7 bytes.
        /// </summary>
        public string SecurityCode
        {
            get => this.data.ExtractString(14, this.data.Length - 14, System.Text.Encoding.UTF8);
            set => this.data.Slice(14).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="DeleteCharacter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator DeleteCharacter(Span<byte> packet) => new DeleteCharacter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="DeleteCharacter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(DeleteCharacter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player selects a character to enter the game world on the character selection screen.
    /// Causes reaction on server side: The player joins the game world with the specified character.
    /// </summary>
    public ref struct SelectCharacter
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SelectCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SelectCharacter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SelectCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SelectCharacter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the name of the character with which the player wants to join the game world
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SelectCharacter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SelectCharacter(Span<byte> packet) => new SelectCharacter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SelectCharacter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SelectCharacter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player focuses (clicks on it) a character with which he plans to enter the game world on the character selection screen.
    /// Causes reaction on server side: The server checks if this character exists and sends a response back. If successful, the game client highlights the focused character.
    /// </summary>
    public ref struct FocusCharacter
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FocusCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FocusCharacter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FocusCharacter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FocusCharacter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FocusCharacter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FocusCharacter(Span<byte> packet) => new FocusCharacter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FocusCharacter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FocusCharacter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player decides to add a stat point to a specific stat type, by pressing a plus-button in the character info menu.
    /// Causes reaction on server side: The server checks if a level-up-point is available. If yes, it adds the point to the specified stat type. It sends a response back to the client.
    /// </summary>
    public ref struct IncreaseCharacterStatPoint
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="IncreaseCharacterStatPoint"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public IncreaseCharacterStatPoint(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IncreaseCharacterStatPoint"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private IncreaseCharacterStatPoint(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the stat type.
        /// </summary>
        public CharacterStatAttribute StatType
        {
            get => (CharacterStatAttribute)this.data.Slice(4).GetByteValue();
            set => this.data.Slice(4).SetByteValue((byte)value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="IncreaseCharacterStatPoint"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator IncreaseCharacterStatPoint(Span<byte> packet) => new IncreaseCharacterStatPoint(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="IncreaseCharacterStatPoint"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(IncreaseCharacterStatPoint packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: After the server sent a map change message and the client has initialized the game map visualization.
    /// Causes reaction on server side: The character is added to the internal game map and ready to interact with other entities.
    /// </summary>
    public ref struct ClientReadyAfterMapChange
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ClientReadyAfterMapChange"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ClientReadyAfterMapChange(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ClientReadyAfterMapChange"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ClientReadyAfterMapChange(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ClientReadyAfterMapChange"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ClientReadyAfterMapChange(Span<byte> packet) => new ClientReadyAfterMapChange(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ClientReadyAfterMapChange"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ClientReadyAfterMapChange packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: When leaving the game world with a character.
    /// Causes reaction on server side: The server saves this configuration in its database.
    /// </summary>
    public ref struct SaveKeyConfiguration
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SaveKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SaveKeyConfiguration(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SaveKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SaveKeyConfiguration(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x30;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the binary data of the key configuration
        /// </summary>
        public Span<byte> Configuration
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SaveKeyConfiguration"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SaveKeyConfiguration(Span<byte> packet) => new SaveKeyConfiguration(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SaveKeyConfiguration"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SaveKeyConfiguration packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player wants to add or increase the level of a specific master skill of the master skill tree.
    /// Causes reaction on server side: Adds or increases the master skill level of the specified skill, if the character is allowed to do that. A response is sent back to the client.
    /// </summary>
    public ref struct AddMasterSkillPoint
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddMasterSkillPoint"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddMasterSkillPoint(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddMasterSkillPoint"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddMasterSkillPoint(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x52;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => this.data.Slice(4).GetShortBigEndian();
            set => this.data.Slice(4).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddMasterSkillPoint"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddMasterSkillPoint(Span<byte> packet) => new AddMasterSkillPoint(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddMasterSkillPoint"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddMasterSkillPoint packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player attacks a target without using a skill.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </summary>
    public ref struct Hit
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Hit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Hit(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Hit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private Hit(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the attack animation.
        /// </summary>
        public byte AttackAnimation
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the looking direction.
        /// </summary>
        public byte LookingDirection
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="Hit"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator Hit(Span<byte> packet) => new Hit(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Hit"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(Hit packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </summary>
    public ref struct TargetedSkill
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TargetedSkill"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TargetedSkill(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TargetedSkill"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TargetedSkill(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x19;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => this.data.Slice(5).GetShortLittleEndian();
            set => this.data.Slice(5).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TargetedSkill"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TargetedSkill(Span<byte> packet) => new TargetedSkill(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TargetedSkill"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TargetedSkill packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </summary>
    public ref struct TargetedSkill075
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TargetedSkill075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TargetedSkill075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TargetedSkill075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TargetedSkill075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x19;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public byte SkillId
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TargetedSkill075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TargetedSkill075(Span<byte> packet) => new TargetedSkill075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TargetedSkill075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TargetedSkill075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player is performing an skill which affects an area of the map.
    /// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
    /// </summary>
    public ref struct AreaSkill
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkill"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AreaSkill(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkill"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AreaSkill(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1E;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the extra target id.
        /// </summary>
        public ushort ExtraTargetId
        {
            get => this.data.Slice(9).GetShortLittleEndian();
            set => this.data.Slice(9).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets animation counter which acts as a reference to the previously sent Area Skill Animation packet.
        /// </summary>
        public byte AnimationCounter
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkill"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AreaSkill(Span<byte> packet) => new AreaSkill(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AreaSkill"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AreaSkill packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: An area skill was performed and the client decided to hit a target.
    /// Causes reaction on server side: The server is calculating the damage and applying it to the target. The attacker gets a response back with the caused damage.
    /// </summary>
    public ref struct AreaSkillHit
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillHit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AreaSkillHit(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillHit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AreaSkillHit(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xDB;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets a sequential hit counter which should prevent that hits are sent multiple times.
        /// </summary>
        public byte HitCounter
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => this.data.Slice(9).GetShortLittleEndian();
            set => this.data.Slice(9).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets a sequential animation counter which acts as a reference to the previously sent Area Skill Animation packet.
        /// </summary>
        public byte AnimationCounter
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillHit"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AreaSkillHit(Span<byte> packet) => new AreaSkillHit(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AreaSkillHit"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AreaSkillHit packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player wants to cancel the trade.
    /// Causes reaction on server side: The trade is cancelled and the previous inventory state is restored.
    /// </summary>
    public ref struct TradeCancel
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeCancel"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeCancel(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeCancel"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeCancel(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3D;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeCancel"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeCancel(Span<byte> packet) => new TradeCancel(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeCancel"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeCancel packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player presses the trade button.
    /// Causes reaction on server side: The state change is forwarded to the trade partner. If both players press the trade button at the same time, the server will try to complete the trade by exchanging the items and money.
    /// </summary>
    public ref struct TradeButtonStateChange
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeButtonStateChange"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeButtonStateChange(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeButtonStateChange"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeButtonStateChange(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3C;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the new state.
        /// </summary>
        public TradeButtonState NewState
        {
            get => (TradeButtonState)this.data.Slice(3).GetByteValue();
            set => this.data.Slice(3).SetByteValue((byte)value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeButtonStateChange"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeButtonStateChange(Span<byte> packet) => new TradeButtonStateChange(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeButtonStateChange"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeButtonStateChange packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: The player requests to open a trade with another player.
    /// Causes reaction on server side: The request is forwarded to the requested player.
    /// </summary>
    public ref struct TradeRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x36;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeRequest(Span<byte> packet) => new TradeRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A requested player responded to a trade request of another player.
    /// Causes reaction on server side: When the trade request was accepted, the server tries to open a new trade and sends corresponding responses to both players. 
    /// </summary>
    public ref struct TradeRequestResponse
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequestResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeRequestResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequestResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeRequestResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x37;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the trade accepted.
        /// </summary>
        public bool TradeAccepted
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequestResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeRequestResponse(Span<byte> packet) => new TradeRequestResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeRequestResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeRequestResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to set an amount of money in the trade.
    /// Causes reaction on server side: It's taken from the available money of the inventory. If the new money amount is lower than the amount which was set before, it's added back to the inventory. The trade partner is informed about any change.
    /// </summary>
    public ref struct SetTradeMoney
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SetTradeMoney"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SetTradeMoney(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SetTradeMoney"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SetTradeMoney(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3A;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the amount.
        /// </summary>
        public uint Amount
        {
            get => this.data.Slice(4).GetIntegerBigEndian();
            set => this.data.Slice(4).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SetTradeMoney"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SetTradeMoney(Span<byte> packet) => new SetTradeMoney(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SetTradeMoney"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SetTradeMoney packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to delete a letter.
    /// Causes reaction on server side: The letter is getting deleted.
    /// </summary>
    public ref struct LetterDeleteRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterDeleteRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LetterDeleteRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterDeleteRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LetterDeleteRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => this.data.Slice(4).GetShortBigEndian();
            set => this.data.Slice(4).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterDeleteRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LetterDeleteRequest(Span<byte> packet) => new LetterDeleteRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LetterDeleteRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LetterDeleteRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to send a letter to another players character.
    /// Causes reaction on server side: The letter is sent to the other character, if it exists and the player has the required money.
    /// </summary>
    public ref struct LetterSendRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterSendRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LetterSendRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterSendRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LetterSendRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4Header Header => new C4Header(this.data);

        /// <summary>
        /// Gets or sets the letter id.
        /// </summary>
        public uint LetterId
        {
            get => this.data.Slice(4).GetIntegerBigEndian();
            set => this.data.Slice(4).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the receiver.
        /// </summary>
        public string Receiver
        {
            get => this.data.ExtractString(8, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(8, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the title.
        /// </summary>
        public string Title
        {
            get => this.data.ExtractString(18, 60, System.Text.Encoding.UTF8);
            set => this.data.Slice(18, 60).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[78];
            set => this.data[78] = value;
        }

        /// <summary>
        /// Gets or sets the animation.
        /// </summary>
        public byte Animation
        {
            get => this.data[79];
            set => this.data[79] = value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(82, this.data.Length - 82, System.Text.Encoding.UTF8);
            set => this.data.Slice(82).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterSendRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LetterSendRequest(Span<byte> packet) => new LetterSendRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LetterSendRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LetterSendRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player requests to read a specific letter of his letter list.
    /// Causes reaction on server side: The server sends the requested letter content back to the game client.
    /// </summary>
    public ref struct LetterReadRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterReadRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LetterReadRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterReadRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LetterReadRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => this.data.Slice(4).GetShortBigEndian();
            set => this.data.Slice(4).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterReadRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LetterReadRequest(Span<byte> packet) => new LetterReadRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LetterReadRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LetterReadRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildKickPlayer
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildKickPlayer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildKickPlayer(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildKickPlayer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildKickPlayer(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x53;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the player name.
        /// </summary>
        public string PlayerName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the password.
        /// </summary>
        public string Password
        {
            get => this.data.ExtractString(14, 20, System.Text.Encoding.UTF8);
            set => this.data.Slice(14, 20).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildKickPlayer"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildKickPlayer(Span<byte> packet) => new GuildKickPlayer(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildKickPlayer"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildKickPlayer packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildJoinRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildJoinRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildJoinRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x50;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the guild master player id.
        /// </summary>
        public ushort GuildMasterPlayerId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildJoinRequest(Span<byte> packet) => new GuildJoinRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildJoinRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildJoinRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildJoinResponse
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildJoinResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildJoinResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x51;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the accepted.
        /// </summary>
        public bool Accepted
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildJoinResponse(Span<byte> packet) => new GuildJoinResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildJoinResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildJoinResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildListRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildListRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildListRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildListRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildListRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x52;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildListRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildListRequest(Span<byte> packet) => new GuildListRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildListRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildListRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildCreateRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildCreateRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildCreateRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildCreateRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildCreateRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x55;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(4, 9, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 9).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildCreateRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildCreateRequest(Span<byte> packet) => new GuildCreateRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildCreateRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildCreateRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildMasterAnswer
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMasterAnswer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMasterAnswer(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMasterAnswer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildMasterAnswer(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x54;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the answer.
        /// </summary>
        public byte Answer
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildMasterAnswer"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildMasterAnswer(Span<byte> packet) => new GuildMasterAnswer(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildMasterAnswer"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildMasterAnswer packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct GuildInfoRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInfoRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildInfoRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInfoRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildInfoRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x66;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public ushort GuildId
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInfoRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildInfoRequest(Span<byte> packet) => new GuildInfoRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildInfoRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildInfoRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct ItemRepair
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemRepair"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemRepair(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemRepair"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemRepair(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x34;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the inventory item slot.
        /// </summary>
        public byte InventoryItemSlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemRepair"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemRepair(Span<byte> packet) => new ItemRepair(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemRepair"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemRepair packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: 
    /// Causes reaction on server side: 
    /// </summary>
    public ref struct ChaosMachineMixRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChaosMachineMixRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChaosMachineMixRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChaosMachineMixRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChaosMachineMixRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x86;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the mix id.
        /// </summary>
        public byte MixId
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChaosMachineMixRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChaosMachineMixRequest(Span<byte> packet) => new ChaosMachineMixRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChaosMachineMixRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChaosMachineMixRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to add another players character into his friend list of the messenger.
    /// Causes reaction on server side: A request is sent to the other player. If the player is currently offline, the request will be sent as soon as he is online again.
    /// </summary>
    public ref struct FriendAddRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAddRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendAddRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAddRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendAddRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC1;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAddRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendAddRequest(Span<byte> packet) => new FriendAddRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendAddRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendAddRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to delete another players character from his friend list of the messenger.
    /// Causes reaction on server side: The entry in the friend list is removed. The player is shown as offline in the other players friends list.
    /// </summary>
    public ref struct FriendDelete
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendDelete"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendDelete(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendDelete"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendDelete(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendDelete"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendDelete(Span<byte> packet) => new FriendDelete(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendDelete"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendDelete packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to open a chat with another player of his friend list.
    /// Causes reaction on server side: If both players are online, a chat room is created on the chat server. Authentication data is sent to both game clients, which will then try to connect to the chat server using this data.
    /// </summary>
    public ref struct ChatRoomCreateRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomCreateRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatRoomCreateRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomCreateRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatRoomCreateRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xCA;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomCreateRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatRoomCreateRequest(Span<byte> packet) => new ChatRoomCreateRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatRoomCreateRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatRoomCreateRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player received a friend request from another player and responded to it.
    /// Causes reaction on server side: If the player accepted, the friend is added to the players friend list and both players get subscribed about each others online status.
    /// </summary>
    public ref struct FriendAddResponse
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAddResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendAddResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAddResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendAddResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC2;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the accepted.
        /// </summary>
        public bool Accepted
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the friend requester name.
        /// </summary>
        public string FriendRequesterName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAddResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendAddResponse(Span<byte> packet) => new FriendAddResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendAddResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendAddResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to set himself on- or offline.
    /// Causes reaction on server side: Depending on the state, the player is shown as offline or online in all friend lists of his friends.
    /// </summary>
    public ref struct SetFriendOnlineState
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SetFriendOnlineState"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SetFriendOnlineState(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SetFriendOnlineState"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SetFriendOnlineState(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the online state.
        /// </summary>
        public bool OnlineState
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SetFriendOnlineState"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SetFriendOnlineState(Span<byte> packet) => new SetFriendOnlineState(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SetFriendOnlineState"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SetFriendOnlineState packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: A player wants to invite additional players from his friend list to an existing chat room.
    /// Causes reaction on server side: The player additional gets authentication data sent to his game client. It then connects to the chat server and joins the chat room.
    /// </summary>
    public ref struct ChatRoomInvitationRequest
    {
        private Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomInvitationRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatRoomInvitationRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomInvitationRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatRoomInvitationRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xCB;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the room id.
        /// </summary>
        public ushort RoomId
        {
            get => this.data.Slice(13).GetShortLittleEndian();
            set => this.data.Slice(13).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the request id.
        /// </summary>
        public uint RequestId
        {
            get => this.data.Slice(15).GetIntegerLittleEndian();
            set => this.data.Slice(15).SetIntegerLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomInvitationRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatRoomInvitationRequest(Span<byte> packet) => new ChatRoomInvitationRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatRoomInvitationRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatRoomInvitationRequest packet) => packet.data; 
    }
        /// <summary>
        /// Defines the values which are used for the character classes on client side.
        /// </summary>
        public enum CharacterClassNumber
        {
            /// <summary>
            /// Value for the dark wizard character class.
            /// </summary>
            DarkWizard = 0,

            /// <summary>
            /// Value for the soul master character class.
            /// </summary>
            SoulMaster = 2,

            /// <summary>
            /// Value for the grand master character class.
            /// </summary>
            GrandMaster = 3,

            /// <summary>
            /// Value for the dark knight character class.
            /// </summary>
            DarkKnight = 4,

            /// <summary>
            /// Value for the blade knight character class.
            /// </summary>
            BladeKnight = 6,

            /// <summary>
            /// Value for the blade master character class.
            /// </summary>
            BladeMaster = 7,

            /// <summary>
            /// Value for the fairy elf character class.
            /// </summary>
            FairyElf = 8,

            /// <summary>
            /// Value for the muse elf character class.
            /// </summary>
            MuseElf = 10,

            /// <summary>
            /// Value for the high elf character class.
            /// </summary>
            HighElf = 11,

            /// <summary>
            /// Value for the magic gladiator character class.
            /// </summary>
            MagicGladiator = 12,

            /// <summary>
            /// Value for the duel master character class.
            /// </summary>
            DuelMaster = 13,

            /// <summary>
            /// Value for the dark lord character class.
            /// </summary>
            DarkLord = 16,

            /// <summary>
            /// Value for the lord emperor character class.
            /// </summary>
            LordEmperor = 17,

            /// <summary>
            /// Value for the summoner character class.
            /// </summary>
            Summoner = 20,

            /// <summary>
            /// Value for the bloody summoner character class.
            /// </summary>
            BloodySummoner = 22,

            /// <summary>
            /// Value for the dimension master character class.
            /// </summary>
            DimensionMaster = 23,

            /// <summary>
            /// Value for the rage fighter character class.
            /// </summary>
            RageFighter = 24,

            /// <summary>
            /// Value for the fist master character class.
            /// </summary>
            FistMaster = 25,
        }

        /// <summary>
        /// Defines the type of a character stat attribute.
        /// </summary>
        public enum CharacterStatAttribute
        {
            /// <summary>
            /// The strength attribute.
            /// </summary>
            Strength = 0,

            /// <summary>
            /// The agility attribute.
            /// </summary>
            Agility = 1,

            /// <summary>
            /// The vitality attribute.
            /// </summary>
            Vitality = 2,

            /// <summary>
            /// The energy attribute.
            /// </summary>
            Energy = 3,

            /// <summary>
            /// The leadership attribute.
            /// </summary>
            Leadership = 4,
        }

        /// <summary>
        /// The state of the trade button.
        /// </summary>
        public enum TradeButtonState
        {
            /// <summary>
            /// Trade button is not pressed. It means that the trade is not yet accepted by the trader.
            /// </summary>
            Unchecked = 0,

            /// <summary>
            /// Trade Button is pressed. It means that the trade is accepted by the trader.
            /// </summary>
            Checked = 1,

            /// <summary>
            /// This state is only sent to the client. After some seconds the client is changing back to normal Unchecked.
            /// </summary>
            Red = 2,
        }

}