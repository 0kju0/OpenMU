// <copyright file="ConnectionExtensions.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
namespace MUnique.OpenMU.Network.Packets.ChatServer
{
    using System;
    using System.Threading;
    using MUnique.OpenMU.Network;

    /// <summary>
    /// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
    /// </summary>
    public static class ConnectionExtensions
    {

        /// <summary>
        /// Starts a safe write of a <see cref="ChatRoomClientJoined" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after another chat client joined the chat room.
        /// Causes reaction on client side: The client will add the client in its list (if over 2 clients are connected to the same room), or show its name in the title bar.
        /// </remarks>
        public static ChatRoomClientJoinedThreadSafeWriter StartWriteChatRoomClientJoined(this IConnection connection)
        {
          return new ChatRoomClientJoinedThreadSafeWriter(connection);
        }

        /// <summary>
        /// Starts a safe write of a <see cref="ChatRoomClientLeft" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after a chat client left the chat room.
        /// Causes reaction on client side: The client will remove the client from its list, or mark its name in the title bar as offline.
        /// </remarks>
        public static ChatRoomClientLeftThreadSafeWriter StartWriteChatRoomClientLeft(this IConnection connection)
        {
          return new ChatRoomClientLeftThreadSafeWriter(connection);
        }

        /// <summary>
        /// Sends a <see cref="ChatRoomClientJoined" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <param name="clientIndex">The client index.</param>
        /// <param name="name">The name.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after another chat client joined the chat room.
        /// Causes reaction on client side: The client will add the client in its list (if over 2 clients are connected to the same room), or show its name in the title bar.
        /// </remarks>
        public static void SendChatRoomClientJoined(this IConnection connection, byte @clientIndex, string @name)
        {
            using var writer = connection.StartWriteChatRoomClientJoined();
            var packet = writer.Packet;
            packet.ClientIndex = @clientIndex;
            packet.Name = @name;
            writer.Commit();
        }

        /// <summary>
        /// Sends a <see cref="ChatRoomClientLeft" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <param name="clientIndex">The client index.</param>
        /// <param name="name">The name.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after a chat client left the chat room.
        /// Causes reaction on client side: The client will remove the client from its list, or mark its name in the title bar as offline.
        /// </remarks>
        public static void SendChatRoomClientLeft(this IConnection connection, byte @clientIndex, string @name)
        {
            using var writer = connection.StartWriteChatRoomClientLeft();
            var packet = writer.Packet;
            packet.ClientIndex = @clientIndex;
            packet.Name = @name;
            writer.Commit();
        }    }
    /// <summary>
    /// A helper struct to write a <see cref="ChatRoomClientJoined"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct ChatRoomClientJoinedThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomClientJoinedThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public ChatRoomClientJoinedThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new ChatRoomClientJoined(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(ChatRoomClientJoined.Length).Slice(0, ChatRoomClientJoined.Length);

        /// <summary>Gets the packet to write at.</summary>
        public ChatRoomClientJoined Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="ChatRoomClientJoined" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(ChatRoomClientJoined.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      
    /// <summary>
    /// A helper struct to write a <see cref="ChatRoomClientLeft"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct ChatRoomClientLeftThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomClientLeftThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public ChatRoomClientLeftThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new ChatRoomClientLeft(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(ChatRoomClientLeft.Length).Slice(0, ChatRoomClientLeft.Length);

        /// <summary>Gets the packet to write at.</summary>
        public ChatRoomClientLeft Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="ChatRoomClientLeft" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(ChatRoomClientLeft.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      }