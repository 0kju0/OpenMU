// <copyright file="ServerToClientPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ServerToClient
{
    using System;

    /// <summary>
    /// Is sent by the server when: After a game client has connected to the game.
    /// Causes reaction on client side: It shows the login dialog.
    /// </summary>
    public readonly ref struct ServerInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public byte Success
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => this.data.Slice(5).GetShortLittleEndian();
            set => this.data.Slice(5).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the version.
        /// </summary>
        public string Version
        {
            get => this.data.ExtractString(7, 5, System.Text.Encoding.UTF8);
            set => this.data.Slice(7, 5).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerInfo(Span<byte> packet) => new ServerInfo(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerInfo packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the login request has been processed by the server.
    /// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
    /// </summary>
    public readonly ref struct LoginResponse
    {
        /// <summary>
        /// The result of a login request.
        /// </summary>
        public enum LoginResult
        {
            /// <summary>
            /// The password was wrong.
            /// </summary>
            InvalidPassword = 0,

            /// <summary>
            /// The login succeeded.
            /// </summary>
            Okay = 1,

            /// <summary>
            /// The account is invalid.
            /// </summary>
            AccountInvalid = 2,

            /// <summary>
            /// The account is already connected.
            /// </summary>
            AccountAlreadyConnected = 3,

            /// <summary>
            /// The server is full.
            /// </summary>
            ServerIsFull = 4,

            /// <summary>
            /// The account is blocked.
            /// </summary>
            AccountBlocked = 5,

            /// <summary>
            /// The game client has the wrong version.
            /// </summary>
            WrongVersion = 6,

            /// <summary>
            /// An internal error occured during connection.
            /// </summary>
            ConnectionError = 7,

            /// <summary>
            /// Connection closed because of three failed login requests.
            /// </summary>
            ConnectionClosed3Fails = 8,

            /// <summary>
            /// There is no payment information.
            /// </summary>
            NoChargeInfo = 9,

            /// <summary>
            /// The subscription term is over.
            /// </summary>
            SubscriptionTermOver = 10,

            /// <summary>
            /// The subscription time is over.
            /// </summary>
            SubscriptionTimeOver = 11,

            /// <summary>
            /// The account is temporarily blocked.
            /// </summary>
            TemporaryBlocked = 14,

            /// <summary>
            /// Only players over 15 years are allowed to connect.
            /// </summary>
            OnlyPlayersOver15Yrs = 17,

            /// <summary>
            /// The client connected from a blocked country.
            /// </summary>
            BadCountry = 210,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LoginResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LoginResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public LoginResult Success
        {
            get => (LoginResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LoginResponse(Span<byte> packet) => new LoginResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LoginResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LoginResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player sends a chat message.
    /// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
    /// </summary>
    public readonly ref struct ChatMessage
    {
        /// <summary>
        /// Defines the type of a chat message.
        /// </summary>
        public enum ChatMessageType
        {
            /// <summary>
            /// The message is a normal chat message, e.g. public, within a party or guild.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The message is sent privately to the receiving player.
            /// </summary>
            Whisper = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ChatMessageType Type
        {
            get => (ChatMessageType)this.data.Slice(2)[0];
            set => this.data.Slice(2)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the sender.
        /// </summary>
        public string Sender
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(13, this.data.Length - 13, System.Text.Encoding.UTF8);
            set => this.data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatMessage(Span<byte> packet) => new ChatMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;
    }


    /// <summary>
    /// Is sent by the server when: A player gained experience.
    /// Causes reaction on client side: The experience is added to the experience counter and bar.
    /// </summary>
    public readonly ref struct ExperienceGained
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ExperienceGained(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ExperienceGained(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x16;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the killed object id.
        /// </summary>
        public ushort KilledObjectId
        {
            get => this.data.Slice(3).GetShortLittleEndian();
            set => this.data.Slice(3).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the added experience.
        /// </summary>
        public ushort AddedExperience
        {
            get => this.data.Slice(5).GetShortLittleEndian();
            set => this.data.Slice(5).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the damage of last hit.
        /// </summary>
        public ushort DamageOfLastHit
        {
            get => this.data.Slice(7).GetShortLittleEndian();
            set => this.data.Slice(7).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ExperienceGained"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ExperienceGained(Span<byte> packet) => new ExperienceGained(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ExperienceGained"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ExperienceGained packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When entering the game world with a character.
    /// Causes reaction on client side: The client restores this configuration in its user interface.
    /// </summary>
    public readonly ref struct ApplyKeyConfiguration
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ApplyKeyConfiguration(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ApplyKeyConfiguration(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x30;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the binary data of the key configuration
        /// </summary>
        public Span<byte> Configuration
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ApplyKeyConfiguration"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ApplyKeyConfiguration(Span<byte> packet) => new ApplyKeyConfiguration(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ApplyKeyConfiguration"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ApplyKeyConfiguration packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Configuration' field from which the size will be calculated.</param>
        public static int GetRequiredSize(Span<byte> content) => content.Length + 4;
    }


    /// <summary>
    /// Is sent by the server when: Periodically, or if the current health or shield changed on the server side, e.g. by hits.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct CurrentHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => this.data.Slice(7).GetShortLittleEndian();
            set => this.data.Slice(7).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentHealthAndShield(Span<byte> packet) => new CurrentHealthAndShield(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the maximum health changed, e.g. by adding stat points or changed items.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct MaximumHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => this.data.Slice(7).GetShortLittleEndian();
            set => this.data.Slice(7).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumHealthAndShield(Span<byte> packet) => new MaximumHealthAndShield(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the consumption of an item failed.
    /// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
    /// </summary>
    public readonly ref struct ItemConsumptionFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemConsumptionFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemConsumptionFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFD;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => this.data.Slice(7).GetShortLittleEndian();
            set => this.data.Slice(7).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemConsumptionFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemConsumptionFailed(Span<byte> packet) => new ItemConsumptionFailed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemConsumptionFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemConsumptionFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The currently available mana or ability has changed, e.g. by using a skill.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct CurrentManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => this.data.Slice(6).GetShortLittleEndian();
            set => this.data.Slice(6).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentManaAndAbility(Span<byte> packet) => new CurrentManaAndAbility(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The maximum available mana or ability has changed, e.g. by adding stat points.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct MaximumManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => this.data.Slice(6).GetShortLittleEndian();
            set => this.data.Slice(6).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumManaAndAbility(Span<byte> packet) => new MaximumManaAndAbility(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
    /// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
    /// </summary>
    public readonly ref struct ConsumeItemWithEffect
    {
        /// <summary>
        /// Defines a consumed item.
        /// </summary>
        public enum ConsumedItemType
        {
            /// <summary>
            /// The player consumes a bottle of ale, usually 80 seconds effect time.
            /// </summary>
            Ale = 0,

            /// <summary>
            /// The player consumes a redemy of love, usually 90 seconds effect time.
            /// </summary>
            RedemyOfLove = 1,

            /// <summary>
            /// The player consumes a potion of soul, usually 60 seconds effect time.
            /// </summary>
            PotionOfSoul = 77,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConsumeItemWithEffect(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConsumeItemWithEffect(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x29;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the item type.
        /// </summary>
        public ConsumedItemType ItemType
        {
            get => (ConsumedItemType)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the effect time in seconds.
        /// </summary>
        public ushort EffectTimeInSeconds
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemWithEffect"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConsumeItemWithEffect(Span<byte> packet) => new ConsumeItemWithEffect(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConsumeItemWithEffect"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConsumeItemWithEffect packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the creation flags.
        /// </summary>
        public byte CreationFlags
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the move cnt.
        /// </summary>
        public byte MoveCnt
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the is vault extended.
        /// </summary>
        public bool IsVaultExtended
        {
            get => this.data.Slice(7).GetBoolean();
            set => this.data.Slice(7).SetBoolean(value);
        }

        /// <summary>
        /// Gets the characterData of the specified index.
        /// </summary>
        public CharacterData this[int index] => new CharacterData(this.data.Slice(8 + (index * CharacterData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList(Span<byte> packet) => new CharacterList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 8;


    /// <summary>
    /// Data of one character in the list..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 34;

        /// <summary>
        /// Gets or sets the slot index.
        /// </summary>
        public byte SlotIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(1, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => this.data.Slice(12).GetShortBigEndian();
            set => this.data.Slice(12).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(14).GetByteValue(4, 0);
            set => this.data.Slice(14).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is item block active.
        /// </summary>
        public bool IsItemBlockActive
        {
            get => this.data.Slice(14).GetBoolean(4);
            set => this.data.Slice(14).SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(15, 18);
        }

        /// <summary>
        /// Gets or sets the guild position.
        /// </summary>
        public GuildMemberRole GuildPosition
        {
            get => (GuildMemberRole)this.data.Slice(33)[0];
            set => this.data.Slice(33)[0] = (byte)value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the characterData of the specified index.
        /// </summary>
        public CharacterData this[int index] => new CharacterData(this.data.Slice(5 + (index * CharacterData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList075(Span<byte> packet) => new CharacterList075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


    /// <summary>
    /// Data of one character in the list..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets or sets the slot index.
        /// </summary>
        public byte SlotIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(1, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => this.data.Slice(11).GetShortBigEndian();
            set => this.data.Slice(11).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(13).GetByteValue(4, 0);
            set => this.data.Slice(13).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is item block active.
        /// </summary>
        public bool IsItemBlockActive
        {
            get => this.data.Slice(13).GetBoolean(4);
            set => this.data.Slice(13).SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(14, 9);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character creation request.
    /// Causes reaction on client side: If successful, the new character is shown in the character list; Otherwise, a message is shown that it failed. 
    /// </summary>
    public readonly ref struct CharacterCreationResult
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterCreationResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterCreationResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(5, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the character slot.
        /// </summary>
        public byte CharacterSlot
        {
            get => this.data[15];
            set => this.data[15] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => this.data.Slice(16).GetShortBigEndian();
            set => this.data.Slice(16).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the class.
        /// </summary>
        public CharacterClassNumber Class
        {
            get => (CharacterClassNumber)this.data.Slice(18).GetByteValue(8, 3);
            set => this.data.Slice(18).SetByteValue((byte)value, 8, 3);
        }

        /// <summary>
        /// Gets or sets the character status.
        /// </summary>
        public byte CharacterStatus
        {
            get => this.data[19];
            set => this.data[19] = value;
        }

        /// <summary>
        /// Gets or sets the preview data.
        /// </summary>
        public Span<byte> PreviewData
        {
            get => this.data.Slice(20);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterCreationResult(Span<byte> packet) => new CharacterCreationResult(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterCreationResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterCreationResult packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'PreviewData' field from which the size will be calculated.</param>
        public static int GetRequiredSize(Span<byte> content) => content.Length + 20;
    }


    /// <summary>
    /// Is sent by the server when: After a the hero state of an observed character changed.
    /// Causes reaction on client side: The color of the name of the character is changed accordingly and a message is shown.
    /// </summary>
    public readonly ref struct HeroStateChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public HeroStateChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private HeroStateChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x08;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the new state.
        /// </summary>
        public CharacterHeroState NewState
        {
            get => (CharacterHeroState)this.data.Slice(6)[0];
            set => this.data.Slice(6)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="HeroStateChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator HeroStateChanged(Span<byte> packet) => new HeroStateChanged(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="HeroStateChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(HeroStateChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.data[4] = 0xFE;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => this.data.Slice(7).GetShortBigEndian();
            set => this.data.Slice(7).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the skill level.
        /// </summary>
        public byte SkillLevel
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAdded(Span<byte> packet) => new SkillAdded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAdded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.data[4] = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => this.data.Slice(7).GetShortBigEndian();
            set => this.data.Slice(7).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillRemoved(Span<byte> packet) => new SkillRemoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
    /// Causes reaction on client side: The skill list gets initialized.
    /// </summary>
    public readonly ref struct SkillListUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the skillEntry of the specified index.
        /// </summary>
        public SkillEntry this[int index] => new SkillEntry(this.data.Slice(6 + (index * SkillEntry.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate(Span<byte> packet) => new SkillListUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 6;


    /// <summary>
    /// Structure for a skill entry of the skill list..
    /// </summary>
    public readonly ref struct SkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => this.data.Slice(1).GetShortBigEndian();
            set => this.data.Slice(1).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the skill level.
        /// </summary>
        public byte SkillLevel
        {
            get => this.data[2];
            set => this.data[2] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillAdded075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAdded075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAdded075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.data[4] = 0xFE;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => this.data.Slice(6).GetShortLittleEndian();
            set => this.data.Slice(6).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAdded075(Span<byte> packet) => new SkillAdded075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAdded075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAdded075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillRemoved075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillRemoved075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillRemoved075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.data[4] = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => this.data.Slice(6).GetShortLittleEndian();
            set => this.data.Slice(6).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillRemoved075(Span<byte> packet) => new SkillRemoved075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillRemoved075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillRemoved075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
    /// Causes reaction on client side: The skill list gets initialized.
    /// </summary>
    public readonly ref struct SkillListUpdate075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the skillEntry of the specified index.
        /// </summary>
        public SkillEntry this[int index] => new SkillEntry(this.data.Slice(5 + (index * SkillEntry.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate075(Span<byte> packet) => new SkillListUpdate075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 5;


    /// <summary>
    /// Structure for a skill entry of the skill list..
    /// </summary>
    public readonly ref struct SkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => this.data.Slice(1).GetShortLittleEndian();
            set => this.data.Slice(1).SetShortLittleEndian(value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the client focused the character successfully on the server side.
    /// Causes reaction on client side: The client highlights the focused character.
    /// </summary>
    public readonly ref struct CharacterFocused
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterFocused(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterFocused(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x15;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterFocused"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterFocused(Span<byte> packet) => new CharacterFocused(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterFocused"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterFocused packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character stat increase request packet.
    /// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
    /// </summary>
    public readonly ref struct CharacterStatIncreaseResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterStatIncreaseResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterStatIncreaseResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean(4);
            set => this.data.Slice(4).SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the attribute.
        /// </summary>
        public CharacterStatAttribute Attribute
        {
            get => (CharacterStatAttribute)this.data.Slice(4).GetByteValue(4, 0);
            set => this.data.Slice(4).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the updated dependent maximum stat.
        /// </summary>
        public ushort UpdatedDependentMaximumStat
        {
            get => this.data.Slice(6).GetShortBigEndian();
            set => this.data.Slice(6).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the updated maximum shield.
        /// </summary>
        public ushort UpdatedMaximumShield
        {
            get => this.data.Slice(8).GetShortBigEndian();
            set => this.data.Slice(8).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the updated maximum ability.
        /// </summary>
        public ushort UpdatedMaximumAbility
        {
            get => this.data.Slice(10).GetShortBigEndian();
            set => this.data.Slice(10).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterStatIncreaseResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterStatIncreaseResponse(Span<byte> packet) => new CharacterStatIncreaseResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterStatIncreaseResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character delete response of the client.
    /// Causes reaction on client side: If successful, the character is deleted from the character selection screen. Otherwise, a message is shown.
    /// </summary>
    public readonly ref struct CharacterDeleteResponse
    {
        /// <summary>
        /// Result of a character delete request.
        /// </summary>
        public enum CharacterDeleteResult
        {
            /// <summary>
            /// Deleting was not successful
            /// </summary>
            Unsuccessful = 0,

            /// <summary>
            /// Deleting was successful
            /// </summary>
            Successful = 1,

            /// <summary>
            /// Deleting was not successful because a wrong security code was entered
            /// </summary>
            WrongSecurityCode = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterDeleteResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterDeleteResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public CharacterDeleteResult Result
        {
            get => (CharacterDeleteResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterDeleteResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterDeleteResponse(Span<byte> packet) => new CharacterDeleteResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterDeleteResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterDeleteResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a character leveled up.
    /// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
    /// </summary>
    public readonly ref struct CharacterLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => this.data.Slice(4).GetShortBigEndian();
            set => this.data.Slice(4).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => this.data.Slice(6).GetShortBigEndian();
            set => this.data.Slice(6).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => this.data.Slice(8).GetShortBigEndian();
            set => this.data.Slice(8).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => this.data.Slice(10).GetShortBigEndian();
            set => this.data.Slice(10).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => this.data.Slice(12).GetShortBigEndian();
            set => this.data.Slice(12).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => this.data.Slice(14).GetShortBigEndian();
            set => this.data.Slice(14).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the fruit points.
        /// </summary>
        public ushort FruitPoints
        {
            get => this.data.Slice(16).GetShortBigEndian();
            set => this.data.Slice(16).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum fruit points.
        /// </summary>
        public ushort MaximumFruitPoints
        {
            get => this.data.Slice(18).GetShortBigEndian();
            set => this.data.Slice(18).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the negative fruit points.
        /// </summary>
        public ushort NegativeFruitPoints
        {
            get => this.data.Slice(20).GetShortBigEndian();
            set => this.data.Slice(20).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum negative fruit points.
        /// </summary>
        public ushort MaximumNegativeFruitPoints
        {
            get => this.data.Slice(22).GetShortBigEndian();
            set => this.data.Slice(22).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterLevelUpdate(Span<byte> packet) => new CharacterLevelUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 72;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public ushort MapId
        {
            get => this.data.Slice(6).GetShortBigEndian();
            set => this.data.Slice(6).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public ulong CurrentExperience
        {
            get => this.data.Slice(8).GetLongLittleEndian();
            set => this.data.Slice(8).SetLongLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public ulong ExperienceForNextLevel
        {
            get => this.data.Slice(16).GetLongLittleEndian();
            set => this.data.Slice(16).SetLongLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => this.data.Slice(24).GetShortBigEndian();
            set => this.data.Slice(24).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => this.data.Slice(26).GetShortBigEndian();
            set => this.data.Slice(26).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => this.data.Slice(28).GetShortBigEndian();
            set => this.data.Slice(28).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => this.data.Slice(30).GetShortBigEndian();
            set => this.data.Slice(30).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => this.data.Slice(32).GetShortBigEndian();
            set => this.data.Slice(32).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => this.data.Slice(34).GetShortBigEndian();
            set => this.data.Slice(34).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => this.data.Slice(36).GetShortBigEndian();
            set => this.data.Slice(36).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => this.data.Slice(38).GetShortBigEndian();
            set => this.data.Slice(38).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => this.data.Slice(40).GetShortBigEndian();
            set => this.data.Slice(40).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current shield.
        /// </summary>
        public ushort CurrentShield
        {
            get => this.data.Slice(42).GetShortBigEndian();
            set => this.data.Slice(42).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => this.data.Slice(44).GetShortBigEndian();
            set => this.data.Slice(44).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current ability.
        /// </summary>
        public ushort CurrentAbility
        {
            get => this.data.Slice(46).GetShortBigEndian();
            set => this.data.Slice(46).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => this.data.Slice(48).GetShortBigEndian();
            set => this.data.Slice(48).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => this.data.Slice(52).GetIntegerBigEndian();
            set => this.data.Slice(52).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data.Slice(56)[0];
            set => this.data.Slice(56)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(57)[0];
            set => this.data.Slice(57)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the used fruit points.
        /// </summary>
        public ushort UsedFruitPoints
        {
            get => this.data.Slice(58).GetShortBigEndian();
            set => this.data.Slice(58).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the max fruit points.
        /// </summary>
        public ushort MaxFruitPoints
        {
            get => this.data.Slice(60).GetShortBigEndian();
            set => this.data.Slice(60).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the leadership.
        /// </summary>
        public ushort Leadership
        {
            get => this.data.Slice(62).GetShortBigEndian();
            set => this.data.Slice(62).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the used negative fruit points.
        /// </summary>
        public ushort UsedNegativeFruitPoints
        {
            get => this.data.Slice(64).GetShortBigEndian();
            set => this.data.Slice(64).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the max negative fruit points.
        /// </summary>
        public ushort MaxNegativeFruitPoints
        {
            get => this.data.Slice(66).GetShortBigEndian();
            set => this.data.Slice(66).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the is vault extended.
        /// </summary>
        public bool IsVaultExtended
        {
            get => this.data.Slice(68).GetBoolean();
            set => this.data.Slice(68).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation(Span<byte> packet) => new CharacterInformation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public byte MapId
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public uint CurrentExperience
        {
            get => this.data.Slice(8).GetIntegerBigEndian();
            set => this.data.Slice(8).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public uint ExperienceForNextLevel
        {
            get => this.data.Slice(12).GetIntegerBigEndian();
            set => this.data.Slice(12).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => this.data.Slice(16).GetShortBigEndian();
            set => this.data.Slice(16).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => this.data.Slice(18).GetShortBigEndian();
            set => this.data.Slice(18).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => this.data.Slice(20).GetShortBigEndian();
            set => this.data.Slice(20).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => this.data.Slice(22).GetShortBigEndian();
            set => this.data.Slice(22).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => this.data.Slice(24).GetShortBigEndian();
            set => this.data.Slice(24).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => this.data.Slice(26).GetShortBigEndian();
            set => this.data.Slice(26).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => this.data.Slice(28).GetShortBigEndian();
            set => this.data.Slice(28).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => this.data.Slice(30).GetShortBigEndian();
            set => this.data.Slice(30).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => this.data.Slice(32).GetShortBigEndian();
            set => this.data.Slice(32).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => this.data.Slice(36).GetIntegerBigEndian();
            set => this.data.Slice(36).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data.Slice(40)[0];
            set => this.data.Slice(40)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(41)[0];
            set => this.data.Slice(41)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation075(Span<byte> packet) => new CharacterInformation075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CharacterInventory
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInventory(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInventory(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4HeaderWithSubCode Header => new C4HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInventory"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInventory(Span<byte> packet) => new CharacterInventory(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInventory"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInventory packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct ItemUpgraded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemUpgraded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemUpgraded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemUpgraded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemUpgraded(Span<byte> packet) => new ItemUpgraded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemUpgraded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemUpgraded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After entering the game with a master class character.
    /// Causes reaction on client side: The master related data is available.
    /// </summary>
    public readonly ref struct MasterStatsUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterStatsUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterStatsUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x50;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 32;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the master level.
        /// </summary>
        public ushort MasterLevel
        {
            get => this.data.Slice(4).GetShortBigEndian();
            set => this.data.Slice(4).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the master experience.
        /// </summary>
        public ulong MasterExperience
        {
            get => this.data.Slice(6).GetLongLittleEndian();
            set => this.data.Slice(6).SetLongLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the master experience of next level.
        /// </summary>
        public ulong MasterExperienceOfNextLevel
        {
            get => this.data.Slice(14).GetLongLittleEndian();
            set => this.data.Slice(14).SetLongLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the master level up points.
        /// </summary>
        public ushort MasterLevelUpPoints
        {
            get => this.data.Slice(22).GetShortBigEndian();
            set => this.data.Slice(22).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => this.data.Slice(24).GetShortBigEndian();
            set => this.data.Slice(24).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => this.data.Slice(26).GetShortBigEndian();
            set => this.data.Slice(26).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => this.data.Slice(28).GetShortBigEndian();
            set => this.data.Slice(28).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => this.data.Slice(30).GetShortBigEndian();
            set => this.data.Slice(30).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterStatsUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterStatsUpdate(Span<byte> packet) => new MasterStatsUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterStatsUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterStatsUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a master skill level has been changed (usually increased).
    /// Causes reaction on client side: The level is updated in the master skill tree.
    /// </summary>
    public readonly ref struct MasterSkillLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterSkillLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x52;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 28;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the master level up points.
        /// </summary>
        public ushort MasterLevelUpPoints
        {
            get => this.data.Slice(6).GetShortBigEndian();
            set => this.data.Slice(6).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
        /// </summary>
        public byte MasterSkillIndex
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the master skill number.
        /// </summary>
        public ushort MasterSkillNumber
        {
            get => this.data.Slice(12).GetShortBigEndian();
            set => this.data.Slice(12).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[16];
            set => this.data[16] = value;
        }

        /// <summary>
        /// Gets or sets the display value.
        /// </summary>
        public float DisplayValue
        {
            get => BitConverter.ToSingle(this.data.Slice(20));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(20));
        }

        /// <summary>
        /// Gets or sets the display value of next level.
        /// </summary>
        public float DisplayValueOfNextLevel
        {
            get => BitConverter.ToSingle(this.data.Slice(24));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(24));
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterSkillLevelUpdate(Span<byte> packet) => new MasterSkillLevelUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterSkillLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterSkillLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually after entering the game with a master character.
    /// Causes reaction on client side: The data is available in the master skill tree.
    /// </summary>
    public readonly ref struct MasterSkillList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterSkillList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x53;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new C2HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the master skill count.
        /// </summary>
        public uint MasterSkillCount
        {
            get => this.data.Slice(8).GetIntegerBigEndian();
            set => this.data.Slice(8).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets the masterSkillEntry of the specified index.
        /// </summary>
        public MasterSkillEntry this[int index] => new MasterSkillEntry(this.data.Slice(12 + (index * MasterSkillEntry.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterSkillList(Span<byte> packet) => new MasterSkillList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterSkillList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterSkillList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="MasterSkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="MasterSkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * MasterSkillEntry.Length + 12;


    /// <summary>
    /// An entry in the master skill list..
    /// </summary>
    public readonly ref struct MasterSkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
        /// </summary>
        public byte MasterSkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[1];
            set => this.data[1] = value;
        }

        /// <summary>
        /// Gets or sets the display value.
        /// </summary>
        public float DisplayValue
        {
            get => BitConverter.ToSingle(this.data.Slice(4));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(4));
        }

        /// <summary>
        /// Gets or sets the display value of next level.
        /// </summary>
        public float DisplayValueOfNextLevel
        {
            get => BitConverter.ToSingle(this.data.Slice(8));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(8));
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct ServerMessage
    {
        /// <summary>
        /// Defines a type of a server message.
        /// </summary>
        public enum MessageType
        {
            /// <summary>
            /// The message is shown as centered golden message in the client.
            /// </summary>
            GoldenCenter = 0,

            /// <summary>
            /// The message is shown as a blue system message.
            /// </summary>
            BlueNormal = 1,

            /// <summary>
            /// The message is a guild notice, centered in green.
            /// </summary>
            GuildNotice = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x0D;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public MessageType Type
        {
            get => (MessageType)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(4, this.data.Length - 4, System.Text.Encoding.UTF8);
            set => this.data.Slice(4).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerMessage(Span<byte> packet) => new ServerMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct PlayerMeet
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerMeet(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerMeet(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the player count.
        /// </summary>
        public byte PlayerCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerMeet"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerMeet(Span<byte> packet) => new PlayerMeet(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerMeet"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerMeet packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct NpcMeet
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcMeet(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcMeet(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the npc count.
        /// </summary>
        public byte NpcCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcMeet"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcMeet(Span<byte> packet) => new NpcMeet(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcMeet"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcMeet packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct MessengerInitialization
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MessengerInitialization(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MessengerInitialization(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC0;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the letter count.
        /// </summary>
        public byte LetterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the maximum letter count.
        /// </summary>
        public byte MaximumLetterCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the friend count.
        /// </summary>
        public byte FriendCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MessengerInitialization"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MessengerInitialization(Span<byte> packet) => new MessengerInitialization(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MessengerInitialization"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MessengerInitialization packet) => packet.data; 
    }
        /// <summary>
        /// Defines the role of a guild member.
        /// </summary>
        public enum GuildMemberRole
        {
            /// <summary>
            /// The member is a normal member without special rights.
            /// </summary>
            NormalMember = 0,

            /// <summary>
            /// The member is a battle master.
            /// </summary>
            BattleMaster = 32,

            /// <summary>
            /// The member is the guild master.
            /// </summary>
            GuildMaster = 128,

            /// <summary>
            /// The character is not a member, therefore the role is undefined.
            /// </summary>
            Undefined = 255,
        }

        /// <summary>
        /// The status of a character.
        /// </summary>
        public enum CharacterStatus
        {
            /// <summary>
            /// The state of the character is normal.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The character is banned from the game.
            /// </summary>
            Banned = 1,

            /// <summary>
            /// The character is a game master.
            /// </summary>
            GameMaster = 32,
        }

}