// <copyright file="ServerToClientPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ServerToClient
{
    using System;

    /// <summary>
    /// Is sent by the server when: After a game client has connected to the game.
    /// Causes reaction on client side: It shows the login dialog.
    /// </summary>
    public readonly ref struct ServerInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public byte Success
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => this.data.Slice(5).GetShortLittleEndian();
            set => this.data.Slice(5).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the version.
        /// </summary>
        public string Version
        {
            get => this.data.ExtractString(7, 5, System.Text.Encoding.UTF8);
            set => this.data.Slice(7, 5).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerInfo(Span<byte> packet) => new ServerInfo(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerInfo packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the login request has been processed by the server.
    /// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
    /// </summary>
    public readonly ref struct LoginResponse
    {
        /// <summary>
        /// The result of a login request.
        /// </summary>
        public enum LoginResult
        {
            /// <summary>
            /// The password was wrong.
            /// </summary>
            InvalidPassword = 0,

            /// <summary>
            /// The login succeeded.
            /// </summary>
            Okay = 1,

            /// <summary>
            /// The account is invalid.
            /// </summary>
            AccountInvalid = 2,

            /// <summary>
            /// The account is already connected.
            /// </summary>
            AccountAlreadyConnected = 3,

            /// <summary>
            /// The server is full.
            /// </summary>
            ServerIsFull = 4,

            /// <summary>
            /// The account is blocked.
            /// </summary>
            AccountBlocked = 5,

            /// <summary>
            /// The game client has the wrong version.
            /// </summary>
            WrongVersion = 6,

            /// <summary>
            /// An internal error occured during connection.
            /// </summary>
            ConnectionError = 7,

            /// <summary>
            /// Connection closed because of three failed login requests.
            /// </summary>
            ConnectionClosed3Fails = 8,

            /// <summary>
            /// There is no payment information.
            /// </summary>
            NoChargeInfo = 9,

            /// <summary>
            /// The subscription term is over.
            /// </summary>
            SubscriptionTermOver = 10,

            /// <summary>
            /// The subscription time is over.
            /// </summary>
            SubscriptionTimeOver = 11,

            /// <summary>
            /// The account is temporarily blocked.
            /// </summary>
            TemporaryBlocked = 14,

            /// <summary>
            /// Only players over 15 years are allowed to connect.
            /// </summary>
            OnlyPlayersOver15Yrs = 17,

            /// <summary>
            /// The client connected from a blocked country.
            /// </summary>
            BadCountry = 210,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LoginResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LoginResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public LoginResult Success
        {
            get => (LoginResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LoginResponse(Span<byte> packet) => new LoginResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LoginResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LoginResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player sends a chat message.
    /// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
    /// </summary>
    public readonly ref struct ChatMessage
    {
        /// <summary>
        /// Defines the type of a chat message.
        /// </summary>
        public enum ChatMessageType
        {
            /// <summary>
            /// The message is a normal chat message, e.g. public, within a party or guild.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The message is sent privately to the receiving player.
            /// </summary>
            Whisper = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ChatMessageType Type
        {
            get => (ChatMessageType)this.data.Slice(2)[0];
            set => this.data.Slice(2)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the sender.
        /// </summary>
        public string Sender
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(13, this.data.Length - 13, System.Text.Encoding.UTF8);
            set => this.data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatMessage(Span<byte> packet) => new ChatMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;
    }
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CurrentHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => this.data.Slice(7).GetShortLittleEndian();
            set => this.data.Slice(7).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentHealthAndShield(Span<byte> packet) => new CurrentHealthAndShield(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct MaximumHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => this.data.Slice(7).GetShortLittleEndian();
            set => this.data.Slice(7).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumHealthAndShield(Span<byte> packet) => new MaximumHealthAndShield(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CurrentManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => this.data.Slice(6).GetShortLittleEndian();
            set => this.data.Slice(6).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentManaAndAbility(Span<byte> packet) => new CurrentManaAndAbility(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct MaximumManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => this.data.Slice(6).GetShortLittleEndian();
            set => this.data.Slice(6).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumManaAndAbility(Span<byte> packet) => new MaximumManaAndAbility(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
    /// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
    /// </summary>
    public readonly ref struct ConsumeItemWithEffect
    {
        /// <summary>
        /// Defines a consumed item.
        /// </summary>
        public enum ConsumedItemType
        {
            /// <summary>
            /// The player consumes a bottle of ale, usually 80 seconds effect time.
            /// </summary>
            Ale = 0,

            /// <summary>
            /// The player consumes a redemy of love, usually 90 seconds effect time.
            /// </summary>
            RedemyOfLove = 1,

            /// <summary>
            /// The player consumes a potion of soul, usually 60 seconds effect time.
            /// </summary>
            PotionOfSoul = 77,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConsumeItemWithEffect(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConsumeItemWithEffect(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x29;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the item type.
        /// </summary>
        public ConsumedItemType ItemType
        {
            get => (ConsumedItemType)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the effect time in seconds.
        /// </summary>
        public ushort EffectTimeInSeconds
        {
            get => this.data.Slice(4).GetShortLittleEndian();
            set => this.data.Slice(4).SetShortLittleEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemWithEffect"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConsumeItemWithEffect(Span<byte> packet) => new ConsumeItemWithEffect(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConsumeItemWithEffect"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConsumeItemWithEffect packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the number of characters.
        /// </summary>
        public byte Numberofcharacters
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList(Span<byte> packet) => new CharacterList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CharacterCreationResult
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterCreationResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterCreationResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public byte Success
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterCreationResult(Span<byte> packet) => new CharacterCreationResult(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterCreationResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterCreationResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct SkillListUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets skill index (when added)
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets skill id (when added)
        /// </summary>
        public ushort SkillId
        {
            get => this.data.Slice(7).GetShortBigEndian();
            set => this.data.Slice(7).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate(Span<byte> packet) => new SkillListUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CharacterFocused
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterFocused(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterFocused(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x15;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterFocused"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterFocused(Span<byte> packet) => new CharacterFocused(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterFocused"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterFocused packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character stat increase request packet.
    /// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
    /// </summary>
    public readonly ref struct CharacterStatIncreaseResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterStatIncreaseResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterStatIncreaseResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets result (first 4 bit) and Stat Type (last 4 bit)
        /// </summary>
        public byte Result
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterStatIncreaseResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterStatIncreaseResponse(Span<byte> packet) => new CharacterStatIncreaseResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterStatIncreaseResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CharacterDeleteResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterDeleteResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterDeleteResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public byte Result
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterDeleteResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterDeleteResponse(Span<byte> packet) => new CharacterDeleteResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterDeleteResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterDeleteResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a character leveled up.
    /// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
    /// </summary>
    public readonly ref struct CharacterLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => this.data.Slice(4).GetShortBigEndian();
            set => this.data.Slice(4).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => this.data.Slice(6).GetShortBigEndian();
            set => this.data.Slice(6).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => this.data.Slice(8).GetShortBigEndian();
            set => this.data.Slice(8).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => this.data.Slice(10).GetShortBigEndian();
            set => this.data.Slice(10).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => this.data.Slice(12).GetShortBigEndian();
            set => this.data.Slice(12).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => this.data.Slice(14).GetShortBigEndian();
            set => this.data.Slice(14).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the fruit points.
        /// </summary>
        public ushort FruitPoints
        {
            get => this.data.Slice(16).GetShortBigEndian();
            set => this.data.Slice(16).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterLevelUpdate(Span<byte> packet) => new CharacterLevelUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public ushort MapId
        {
            get => this.data.Slice(6).GetShortBigEndian();
            set => this.data.Slice(6).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public ulong CurrentExperience
        {
            get => this.data.Slice(8).GetLongLittleEndian();
            set => this.data.Slice(8).SetLongLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public ulong ExperienceForNextLevel
        {
            get => this.data.Slice(16).GetLongLittleEndian();
            set => this.data.Slice(16).SetLongLittleEndian(value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => this.data.Slice(24).GetShortBigEndian();
            set => this.data.Slice(24).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => this.data.Slice(26).GetShortBigEndian();
            set => this.data.Slice(26).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => this.data.Slice(28).GetShortBigEndian();
            set => this.data.Slice(28).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => this.data.Slice(30).GetShortBigEndian();
            set => this.data.Slice(30).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => this.data.Slice(32).GetShortBigEndian();
            set => this.data.Slice(32).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => this.data.Slice(34).GetShortBigEndian();
            set => this.data.Slice(34).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => this.data.Slice(36).GetShortBigEndian();
            set => this.data.Slice(36).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => this.data.Slice(38).GetShortBigEndian();
            set => this.data.Slice(38).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => this.data.Slice(40).GetShortBigEndian();
            set => this.data.Slice(40).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current shield.
        /// </summary>
        public ushort CurrentShield
        {
            get => this.data.Slice(42).GetShortBigEndian();
            set => this.data.Slice(42).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => this.data.Slice(44).GetShortBigEndian();
            set => this.data.Slice(44).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the current ability.
        /// </summary>
        public ushort CurrentAbility
        {
            get => this.data.Slice(46).GetShortBigEndian();
            set => this.data.Slice(46).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => this.data.Slice(48).GetShortBigEndian();
            set => this.data.Slice(48).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the unknown.
        /// </summary>
        public ushort Unknown
        {
            get => this.data.Slice(50).GetShortBigEndian();
            set => this.data.Slice(50).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => this.data.Slice(52).GetIntegerBigEndian();
            set => this.data.Slice(52).SetIntegerBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the player kill level.
        /// </summary>
        public byte PlayerKillLevel
        {
            get => this.data[56];
            set => this.data[56] = value;
        }

        /// <summary>
        /// Gets or sets the ctl code.
        /// </summary>
        public byte CtlCode
        {
            get => this.data[57];
            set => this.data[57] = value;
        }

        /// <summary>
        /// Gets or sets the used fruit points.
        /// </summary>
        public ushort UsedFruitPoints
        {
            get => this.data.Slice(58).GetShortBigEndian();
            set => this.data.Slice(58).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the max fruit points.
        /// </summary>
        public ushort MaxFruitPoints
        {
            get => this.data.Slice(58).GetShortBigEndian();
            set => this.data.Slice(58).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the command.
        /// </summary>
        public ushort Command
        {
            get => this.data.Slice(60).GetShortBigEndian();
            set => this.data.Slice(60).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the used negative fruit points.
        /// </summary>
        public ushort UsedNegativeFruitPoints
        {
            get => this.data.Slice(62).GetShortBigEndian();
            set => this.data.Slice(62).SetShortBigEndian(value);
        }

        /// <summary>
        /// Gets or sets the max negative fruit points.
        /// </summary>
        public ushort MaxNegativeFruitPoints
        {
            get => this.data.Slice(64).GetShortBigEndian();
            set => this.data.Slice(64).SetShortBigEndian(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation(Span<byte> packet) => new CharacterInformation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct CharacterInventory
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInventory(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInventory(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4HeaderWithSubCode Header => new C4HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInventory"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInventory(Span<byte> packet) => new CharacterInventory(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInventory"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInventory packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct ItemUpgraded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemUpgraded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemUpgraded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemUpgraded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemUpgraded(Span<byte> packet) => new ItemUpgraded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemUpgraded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemUpgraded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct ServerMessage
    {
        /// <summary>
        /// Defines a type of a server message.
        /// </summary>
        public enum MessageType
        {
            /// <summary>
            /// The message is shown as centered golden message in the client.
            /// </summary>
            GoldenCenter = 0,

            /// <summary>
            /// The message is shown as a blue system message.
            /// </summary>
            BlueNormal = 1,

            /// <summary>
            /// The message is a guild notice, centered in green.
            /// </summary>
            GuildNotice = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x0D;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public MessageType Type
        {
            get => (MessageType)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(4, this.data.Length - 4, System.Text.Encoding.UTF8);
            set => this.data.Slice(4).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerMessage(Span<byte> packet) => new ServerMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct PlayerMeet
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerMeet(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerMeet(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the player count.
        /// </summary>
        public byte PlayerCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerMeet"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerMeet(Span<byte> packet) => new PlayerMeet(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerMeet"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerMeet packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct NpcMeet
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcMeet(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcMeet"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcMeet(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the npc count.
        /// </summary>
        public byte NpcCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcMeet"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcMeet(Span<byte> packet) => new NpcMeet(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcMeet"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcMeet packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct MessengerInitialization
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MessengerInitialization(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MessengerInitialization(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC0;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the letter count.
        /// </summary>
        public byte LetterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the maximum letter count.
        /// </summary>
        public byte MaximumLetterCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the friend count.
        /// </summary>
        public byte FriendCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MessengerInitialization"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MessengerInitialization(Span<byte> packet) => new MessengerInitialization(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MessengerInitialization"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MessengerInitialization packet) => packet.data; 
    }
}