// <copyright file="PacketHeaders.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets;

using System;
using static System.Buffers.Binary.BinaryPrimitives;

/// <summary>
/// The structure for a C1 packet header. Usually encrypted by Xor32..
/// </summary>
public readonly struct C1Header
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C1Header"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C1Header(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data.Span[1];
        set => this._data.Span[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }
}


/// <summary>
/// The structure for a C1 packet header with sub code. Usually encrypted by Xor32..
/// </summary>
public readonly struct C1HeaderWithSubCode
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C1HeaderWithSubCode"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C1HeaderWithSubCode(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data.Span[1];
        set => this._data.Span[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }
}


/// <summary>
/// The structure for a C2 packet header. Usually encrypted by Xor32..
/// </summary>
public readonly struct C2Header
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C2Header"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C2Header(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data.Span[1..]);
        set => WriteUInt16BigEndian(this._data.Span[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }
}


/// <summary>
/// The structure for a C2 packet header. Usually encrypted by Xor32..
/// </summary>
public readonly struct C2HeaderWithSubCode
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C2HeaderWithSubCode"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C2HeaderWithSubCode(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data.Span[1..]);
        set => WriteUInt16BigEndian(this._data.Span[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }
}


/// <summary>
/// The structure for a C3 packet header. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly struct C3Header
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C3Header"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C3Header(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data.Span[1];
        set => this._data.Span[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }
}


/// <summary>
/// The structure for a C3 packet header with sub code. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly struct C3HeaderWithSubCode
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C3HeaderWithSubCode"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C3HeaderWithSubCode(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data.Span[1];
        set => this._data.Span[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }
}


/// <summary>
/// The structure for a C4 packet header. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly struct C4Header
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C4Header"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C4Header(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data.Span[1..]);
        set => WriteUInt16BigEndian(this._data.Span[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }
}


/// <summary>
/// The structure for a C4 packet header with sub code. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly struct C4HeaderWithSubCode
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C4HeaderWithSubCode"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C4HeaderWithSubCode(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data.Span[1..]);
        set => WriteUInt16BigEndian(this._data.Span[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }
}
