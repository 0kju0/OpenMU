// <copyright file="ConnectionExtensions.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
// ReSharper disable UnusedMember.Global
// ReSharper disable UseObjectOrCollectionInitializer

#nullable enable
namespace MUnique.OpenMU.Network.Packets.ConnectServer;

using System;
using System.Threading;
using MUnique.OpenMU.Network;

/// <summary>
/// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
/// </summary>
public static class ConnectionExtensions
{

    /// <summary>
    /// Sends a <see cref="ConnectionInfoRequest075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="serverId">The server id.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </remarks>
    public static async ValueTask SendConnectionInfoRequest075Async(this IConnection? connection, byte @serverId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ConnectionInfoRequest075Ref.Length;
            var packet = new ConnectionInfoRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.ServerId = @serverId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ConnectionInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="serverId">The server id.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </remarks>
    public static async ValueTask SendConnectionInfoRequestAsync(this IConnection? connection, ushort @serverId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ConnectionInfoRequestRef.Length;
            var packet = new ConnectionInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ServerId = @serverId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ConnectionInfo" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="ipAddress">The ip address.</param>
    /// <param name="port">The port.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client requested the connection information of a server. This happens after the user clicked on a server.
    /// Causes reaction on client side: The client will try to connect to the server with the specified information.
    /// </remarks>
    public static async ValueTask SendConnectionInfoAsync(this IConnection? connection, string @ipAddress, ushort @port)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ConnectionInfoRef.Length;
            var packet = new ConnectionInfoRef(connection.Output.GetSpan(length)[..length]);
            packet.IpAddress = @ipAddress;
            packet.Port = @port;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ServerListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponse back to the client.
    /// </remarks>
    public static async ValueTask SendServerListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ServerListRequestRef.Length;
            var packet = new ServerListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ServerListRequestOld" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client (below season 1) after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponseOld back to the client.
    /// </remarks>
    public static async ValueTask SendServerListRequestOldAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ServerListRequestOldRef.Length;
            var packet = new ServerListRequestOldRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="Hello" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client connected to the server.
    /// Causes reaction on client side: A game client will request the server list. The launcher would request the patch state.
    /// </remarks>
    public static async ValueTask SendHelloAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = HelloRef.Length;
            var packet = new HelloRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PatchCheckRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="majorVersion">The major version.</param>
    /// <param name="minorVersion">The minor version.</param>
    /// <param name="patchVersion">The patch version.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client (launcher) to check if the patch version is high enough to be able to connect to the server.
    /// Causes reaction on server side: The connect server will check the version and sends a 'PatchVersionOkay' or a 'ClientNeedsPatch' message.
    /// </remarks>
    public static async ValueTask SendPatchCheckRequestAsync(this IConnection? connection, byte @majorVersion, byte @minorVersion, byte @patchVersion)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PatchCheckRequestRef.Length;
            var packet = new PatchCheckRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.MajorVersion = @majorVersion;
            packet.MinorVersion = @minorVersion;
            packet.PatchVersion = @patchVersion;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PatchVersionOkay" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested the to check the patch version and it was high enough.
    /// Causes reaction on client side: The launcher will activate its start button.
    /// </remarks>
    public static async ValueTask SendPatchVersionOkayAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PatchVersionOkayRef.Length;
            var packet = new PatchVersionOkayRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ClientNeedsPatch" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="patchVersion">The patch version.</param>
    /// <param name="patchAddress">The patch address, usually to a ftp server. The address is usually "encrypted" with the 3-byte XOR key (FC CF AB).</param>
    /// <remarks>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested to check the patch version and it requires an update.
    /// Causes reaction on client side: The launcher will download the required patches and then activate the start button.
    /// </remarks>
    public static async ValueTask SendClientNeedsPatchAsync(this IConnection? connection, byte @patchVersion, string @patchAddress)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ClientNeedsPatchRef.Length;
            var packet = new ClientNeedsPatchRef(connection.Output.GetSpan(length)[..length]);
            packet.PatchVersion = @patchVersion;
            packet.PatchAddress = @patchAddress;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }}