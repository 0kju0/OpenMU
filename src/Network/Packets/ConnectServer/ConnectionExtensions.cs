// <copyright file="ConnectionExtensions.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
namespace MUnique.OpenMU.Network.Packets.ConnectServer
{
    using System;
    using System.Threading;
    using MUnique.OpenMU.Network;

    /// <summary>
    /// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
    /// </summary>
    public static class ConnectionExtensions
    {

        /// <summary>
        /// Starts a safe write of a <see cref="ConnectionInfo" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client requested the connection information of a server. This happens after the user clicked on a server.
        /// Causes reaction on client side: The client will try to connect to the server with the specified information.
        /// </remarks>
        public static ConnectionInfoThreadSafeWriter StartWriteConnectionInfo(this IConnection connection)
        {
          return new ConnectionInfoThreadSafeWriter(connection);
        }

        /// <summary>
        /// Starts a safe write of a <see cref="Hello" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client connected to the server.
        /// Causes reaction on client side: A game client will request the server list. The launcher would request the patch state.
        /// </remarks>
        public static HelloThreadSafeWriter StartWriteHello(this IConnection connection)
        {
          return new HelloThreadSafeWriter(connection);
        }

        /// <summary>
        /// Starts a safe write of a <see cref="PatchCheckRequest" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the client when: This packet is sent by the client (launcher) to check if the patch version is high enough to be able to connect to the server.
        /// Causes reaction on server side: The connect server will check the version and sends a 'PatchVersionOkay' or a 'ClientNeedsPatch' message.
        /// </remarks>
        public static PatchCheckRequestThreadSafeWriter StartWritePatchCheckRequest(this IConnection connection)
        {
          return new PatchCheckRequestThreadSafeWriter(connection);
        }

        /// <summary>
        /// Starts a safe write of a <see cref="PatchVersionOkay" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested the to check the patch version and it was high enough.
        /// Causes reaction on client side: The launcher will activate its start button.
        /// </remarks>
        public static PatchVersionOkayThreadSafeWriter StartWritePatchVersionOkay(this IConnection connection)
        {
          return new PatchVersionOkayThreadSafeWriter(connection);
        }

        /// <summary>
        /// Starts a safe write of a <see cref="ClientNeedsPatch" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested to check the patch version and it requires an update.
        /// Causes reaction on client side: The launcher will download the required patches and then activate the start button.
        /// </remarks>
        public static ClientNeedsPatchThreadSafeWriter StartWriteClientNeedsPatch(this IConnection connection)
        {
          return new ClientNeedsPatchThreadSafeWriter(connection);
        }

        /// <summary>
        /// Sends a <see cref="ConnectionInfo" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <param name="ipAddress">The ip address.</param>
        /// <param name="port">The port.</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client requested the connection information of a server. This happens after the user clicked on a server.
        /// Causes reaction on client side: The client will try to connect to the server with the specified information.
        /// </remarks>
        public static void SendConnectionInfo(this IConnection connection, string @ipAddress, ushort @port)
        {
            using var writer = connection.StartWriteConnectionInfo();
            var packet = writer.Packet;
            packet.IpAddress = @ipAddress;
            packet.Port = @port;
            writer.Commit();
        }

        /// <summary>
        /// Sends a <see cref="Hello" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client connected to the server.
        /// Causes reaction on client side: A game client will request the server list. The launcher would request the patch state.
        /// </remarks>
        public static void SendHello(this IConnection connection)
        {
            using var writer = connection.StartWriteHello();
            writer.Commit();
        }

        /// <summary>
        /// Sends a <see cref="PatchCheckRequest" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <param name="majorVersion">The major version.</param>
        /// <param name="minorVersion">The minor version.</param>
        /// <param name="patchVersion">The patch version.</param>
        /// <remarks>
        /// Is sent by the client when: This packet is sent by the client (launcher) to check if the patch version is high enough to be able to connect to the server.
        /// Causes reaction on server side: The connect server will check the version and sends a 'PatchVersionOkay' or a 'ClientNeedsPatch' message.
        /// </remarks>
        public static void SendPatchCheckRequest(this IConnection connection, byte @majorVersion, byte @minorVersion, byte @patchVersion)
        {
            using var writer = connection.StartWritePatchCheckRequest();
            var packet = writer.Packet;
            packet.MajorVersion = @majorVersion;
            packet.MinorVersion = @minorVersion;
            packet.PatchVersion = @patchVersion;
            writer.Commit();
        }

        /// <summary>
        /// Sends a <see cref="PatchVersionOkay" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested the to check the patch version and it was high enough.
        /// Causes reaction on client side: The launcher will activate its start button.
        /// </remarks>
        public static void SendPatchVersionOkay(this IConnection connection)
        {
            using var writer = connection.StartWritePatchVersionOkay();
            writer.Commit();
        }

        /// <summary>
        /// Sends a <see cref="ClientNeedsPatch" /> to this connection.
        /// </summary>
        /// <param name="connection">The connection.</param>
    
        /// <param name="patchVersion">The patch version.</param>
        /// <param name="patchAddress">The patch address, usually to a ftp server. The address is usually "encrypted" with the 3-byte XOR key (FC CF AB).</param>
        /// <remarks>
        /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested to check the patch version and it requires an update.
        /// Causes reaction on client side: The launcher will download the required patches and then activate the start button.
        /// </remarks>
        public static void SendClientNeedsPatch(this IConnection connection, byte @patchVersion, string @patchAddress)
        {
            using var writer = connection.StartWriteClientNeedsPatch();
            var packet = writer.Packet;
            packet.PatchVersion = @patchVersion;
            packet.PatchAddress = @patchAddress;
            writer.Commit();
        }    }
    /// <summary>
    /// A helper struct to write a <see cref="ConnectionInfo"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct ConnectionInfoThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfoThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public ConnectionInfoThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new ConnectionInfo(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(ConnectionInfo.Length).Slice(0, ConnectionInfo.Length);

        /// <summary>Gets the packet to write at.</summary>
        public ConnectionInfo Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="ConnectionInfo" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(ConnectionInfo.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      
    /// <summary>
    /// A helper struct to write a <see cref="Hello"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct HelloThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="HelloThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public HelloThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new Hello(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(Hello.Length).Slice(0, Hello.Length);

        /// <summary>Gets the packet to write at.</summary>
        public Hello Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="Hello" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(Hello.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      
    /// <summary>
    /// A helper struct to write a <see cref="PatchCheckRequest"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct PatchCheckRequestThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="PatchCheckRequestThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public PatchCheckRequestThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new PatchCheckRequest(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(PatchCheckRequest.Length).Slice(0, PatchCheckRequest.Length);

        /// <summary>Gets the packet to write at.</summary>
        public PatchCheckRequest Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="PatchCheckRequest" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(PatchCheckRequest.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      
    /// <summary>
    /// A helper struct to write a <see cref="PatchVersionOkay"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct PatchVersionOkayThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="PatchVersionOkayThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public PatchVersionOkayThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new PatchVersionOkay(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(PatchVersionOkay.Length).Slice(0, PatchVersionOkay.Length);

        /// <summary>Gets the packet to write at.</summary>
        public PatchVersionOkay Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="PatchVersionOkay" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(PatchVersionOkay.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      
    /// <summary>
    /// A helper struct to write a <see cref="ClientNeedsPatch"/> safely to a <see cref="IConnection.Output" />.
    /// </summary>
    public readonly ref struct ClientNeedsPatchThreadSafeWriter
    {
        private readonly IConnection connection;

        /// <summary>
        /// Initializes a new instance of the <see cref="ClientNeedsPatchThreadSafeWriter" /> struct.
        /// </summary>
        /// <param name="connection">The connection.</param>
        public ClientNeedsPatchThreadSafeWriter(IConnection connection)
        {
            this.connection = connection;
            Monitor.Enter(this.connection);
            try
            {
                // Initialize header and default values
                var span = this.Span;
                span.Clear();
                _ = new ClientNeedsPatch(span);
            }
            catch (InvalidOperationException)
            {
                Monitor.Exit(this.connection);
                throw;
            }
        }

        /// <summary>Gets the span to write at.</summary>
        private Span<byte> Span => this.connection.Output.GetSpan(ClientNeedsPatch.Length).Slice(0, ClientNeedsPatch.Length);

        /// <summary>Gets the packet to write at.</summary>
        public ClientNeedsPatch Packet => this.Span;

        /// <summary>
        /// Commits the data of the <see cref="ClientNeedsPatch" />.
        /// </summary>
        public void Commit()
        {
            this.connection.Output.Advance(ClientNeedsPatch.Length);
            this.connection.Output.FlushAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(this.connection);
        }
    }
      }