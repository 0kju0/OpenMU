<# 
// <copyright file="ExtendedJoinEntities.tt" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>
#>
<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)\MUnique.OpenMU.DataModel.dll" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="MUnique.OpenMU.DataModel.Entities" #>
<#@ import namespace="MUnique.OpenMU.Persistence.EntityFramework" #>
<#@ output extension=".cs" #>
// <copyright file="ExtendedJoinEntities.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by a T4 template.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Persistence.EntityFramework
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations.Schema;
    
<#
Assembly assembly = typeof(MUnique.OpenMU.DataModel.Entities.Account).Assembly;
var customTypes = assembly.GetTypes().Where(type => type.IsClass && type.IsPublic && !type.IsSealed && !type.IsAbstract).ToList();
string customTypeSuffix = string.Empty;

var joinProperties = customTypes.SelectMany(t => t.GetProperties().Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>))).ToList();

foreach (PropertyInfo propertyInfo in joinProperties)
{
    var keyType = propertyInfo.PropertyType.GenericTypeArguments[0];
    var elementType = propertyInfo.PropertyType.GenericTypeArguments[1];
    var joinTypeName = propertyInfo.DeclaringType.Name + elementType.Name;
    #>
    [Table("<#=joinTypeName#>", Schema = "<#=propertyInfo.DeclaringType.IsConfigurationType() ? "config" : "data" #>")]
    internal partial class <#=joinTypeName#> : IDictionaryEntity<<#=keyType.Name#>, <#=elementType.Name + customTypeSuffix#>>
    {
        public <#=keyType.Name#> Key { get; set; }

        public Guid ValueId { get; set; }

        [ForeignKey("ValueId")]
        public <#=elementType.Name + customTypeSuffix#> Value { get; set; }
    }

<#
}
#>
<#
var standaloneCollectionProperties = customTypes
    .Where(t => t != typeof(MUnique.OpenMU.DataModel.Configuration.GameConfiguration))
    .SelectMany(t => t.GetProperties().Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) && ExtendedModelMetaData.StandaloneTypes.Contains(p.PropertyType.GenericTypeArguments[0])))
    .ToList();

foreach (PropertyInfo propertyInfo in standaloneCollectionProperties)
{
    var elementType = propertyInfo.PropertyType.GenericTypeArguments[0];
    var joinTypeName = propertyInfo.DeclaringType.Name + elementType.Name;
    #>
    [Table("<#=joinTypeName#>", Schema = "<#=propertyInfo.DeclaringType.IsConfigurationType() ? "config" : "data" #>")]
    internal partial class <#=joinTypeName#> 
    {
        public Guid <#=propertyInfo.DeclaringType.Name#>Id { get; set; }
        public <#=propertyInfo.DeclaringType.Name + customTypeSuffix#> <#=propertyInfo.DeclaringType.Name#> { get; set; }

        public Guid <#=elementType.Name#>Id { get; set; }
        public <#=elementType.Name + customTypeSuffix#> <#=elementType.Name#> { get; set; }
    }

    internal partial class <#=propertyInfo.DeclaringType.Name + customTypeSuffix#>
    {
        public ICollection<<#=joinTypeName#>> Joined<#=propertyInfo.Name#> { get; } = new List<<#=joinTypeName#>>();
    }

<#
}
#>
}